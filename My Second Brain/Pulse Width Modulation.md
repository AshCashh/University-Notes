---
tags: [cs]
Created: 2023-06-27T14:15:42+10:00
Modified: 2024-07-03T19:35:33+10:00
---
Pulse width modulation (PWM) is a technique used to generate a periodic signal with a variable duty cycle. 

A PWM signal is characterised in terms of its [[Frequency]] and duty cycle. The frequency is determined by the number of cycles of the PWM waveform per second and it just the reciprocal of the PWM period:
$$f_{PWM}=\cfrac{1}{T_{PWM}}=\cfrac{1}{T_{timer}}=\cfrac{1}{TOP\times T_{clk}}$$
The duty cycle $D$, of a signal is a measure of the ratio of the HIGH time of the signal compared to the total PWM period.
$$D=\cfrac{T_{HIGH}}{T_{HIGH}+T_{LOW}}=\cfrac{T_{HIGH}}{T}$$
A duty cycle can range from 0% to 100%. A cycle of 0% means the signal net is always LOW, while a cycle of 100% means the signal net is always HIGH.

PWM can be used as a form of digital to analogue conversion, where a modulating signal is used to set the duty cycle of a PWM output. In analogue, a triangular waveform known as the carrier is compared with this modulating signal so that the PWM output is HIGH when the modulating signal is greater than the carrier.
##### Duty Cycle Example
![[Pasted image 20230501171741.png]]

## PWM Implementation
On the ATtiny1626, the carrier is generated by a timer counter (i.e., `TACA0.CNT`) and the modulating signal is the compare value to `TCAO.CCMP`. By setting the compare value to a value less than the counter value, the PWM output's duty cycle can be controlled, via the following equation:
$$D_{PWM} = \cfrac{TCAO.CCMP}{TCAO.CNT+1}$$
### PWM Brightness Control Example
```c
#include <avr/io.h>
#include <avr/interrupt.h>

void tca_init() {
	// DISP EN
	PORTB.DIR = PIN1_bm;

	// Set waveform generation mode to single slope
	// Waveform output controls PA1 PWM (display brightness)
	TCAO.SINGLE.CTRLB = TCA_SINGLE_WGMODE_SINGLESLOPE_gc | TCA_SINGLE_CMP1EN_bm;
	TCAO.SINGLE.PER = 0xFF; // Set period to some value
	TCAO.SINGLE.CMP1 = 0xFF; // 100% duty cycle
	TCAO.SINGLE.CTRLA = TCA_SINGLE_ENABLE_bm; // Enable TCAO
}

int main(void){
	sei();
	tca_init();
	cli();

	while(1);
}
```
To dynamically change the brightness of the display, the compare value can be changed using the buffered register `TCAO.SINGLE.CMP1BUF`. The same applies to the period.

## Studio Example
```c
#include <avr/io.h>
#include <avr/interrupt.h>
#include <qut.serial.h>

void pmw_init(){
	// Turn LED off
	PORTB.OUTSET = PIN5_bm;
	PORTB.DIRSET = PIN5_bm;

	PORTMUX.TCA0
	 

}

void adc_init(){

}


int main(void){

	cli();
	pmw_init();
	adc_init();
	sei();

	while (1);

}

```


## Driving the Buzzer
The human ear can typically perceieve sounds in the range of 20Hz - 20kHz. To drive a buzzer such that it makes a sound, we need to drive it with a signal that has frequency content in this range. For maximum volume, we should drive the buzzer at 50% duty cycle. To produce different tones, we drive the buzzer with different frequencies.

On the QUTy the buzzer is connected between `PB0` and `GND`, which can be controlled by `TCA0` Waveform Output 0 (WO0). If we dont want to drive the buzzer, we should either leave the output in [[High-Impedance Outputs|high impedance]], or drive it LOW

To drive the buzzer to produce an audible tone, we produce a square wave signal on `WO0` with **50% duty cycle** and a **frequency** equal to that of the tone we want to produce. You will need to modify both the period and compare registers of `TCA0` to change the freqency while keeping the duty cycle constant.

## Timer Counter A
Timer Counter A (TCA) is more complex than `TCB` but is well suited to PWM and frequency generation. We will however limit our discussion to single-slope PWM mode. When reading the datasheet make sure to look at the chart in normal mode.

### Clock configuration
The only clock source for `TCA` is `CLK_PER` (same frequency as the CPU clock). The `TCA` clock frequency is configured via register `TCA0.CTRLA`, this register contains the ENABLE bit but should only be enabled once all other figuration is complete.

### Single Slope PWM
In single slope the counter (TCA0.CNT) counts from BOTTOM to TOP and then resets to BOTTOM (BOTTOM = 0, TOP = TCA0.PER). The PWM output for a waveform output is generated by comparing the counter value to the value stored in the corresponding compare register (`WOn` set when CNT == BOTTOM, `WOn` cleared when CNT == CMPn). There are three different `WO`, (WO0, WO1, WO2) which are mapped to different pins and controlled by different `CMP` registers (CMP0, CMP1, CMP2). The pin state will be automatically overriden by the `TCA` peripheral for any `WO`s that are enabled, but the pin must still be configured as an output via the `PORTx.DIR` register for this to occur. If you need to use alternate pin locations for the `WO` you might also need to configure the `PORTMUX`. We have to enable single slope PWM mode and each of the `WO`s we want to use via `TCA0.CTRLB`.

### Double Buffering
The period (TCA0.PER) and compare (TCA0.CMPn) registers are double buffered. 
- This means that we have separate buffer registers (or shadow registers) that we can write to instead of writing to PER or CMPn directly (TCA0.PERBUF, TCA0.CMPnBUF).
- This is useful because if we update PER or CMPn at the wrong time, it could result in a compare to CNT being missed.
- To avoid this, we write to the buffered version of the registers, and the hardware copies from the buffer registers into the active registers at a safe time.
- For single-slope PWM mode, updates will occur when CNT = BOTTOM.

### [[Interrupts]]
The TCA (in normal mode) has four interrupt sources: OVF, CMP0, CMP1, CMP2. Note that each of these sources is handled by a separate interrupt vector. The CMPn interrupts are triggered when CNT == CMPn for the respective channel. For single-slope PWM mode, the OVF interrupt is triggered when CNT == TOP. Each of these interrupts can be independently enabled via TCA0.INTCTRL.

### Reccommended configuration steps
1. Disable interrupts globally via cli()
2. Configure clock prescaler via `TCA0.CTRLA`
3. Select mode and enable `WO` channels via `TCA0.CTRLB`
4. (optional) Enable any interrupt sources required via `TCA0.INTCTRL` (make sure you declare an ISR to handle these)
5. Set the counter period (PWM frequency) via `TCA0.PER`
6. Set initial duty cycles via `TCA0.CMPn`
7. Enable `TCA0` by setting bit ENABLE in `TCA0.CTRLA`
8. Enable interrupts globally via sei()

During operation, write to `TCA0.CMPnBUF` to change the `WOn` duty cycle, write to `TCA0.PERBUF` to change the PWM frequency (this would also affect the `WO` duty cycle if you dont update the corresponding CMP value accordingly)

For applications where you want to ensure that you update duty cycle and/or frequency every cycle, these writes should be synchronised to the counter using interrupts

### TCA0 Initialisation Example
Note .SINGLE is for normal mode not SPLIT mode.
In actual code .SINGLE.REGISTER
```c
void pwm_init() {
	// TCA0 will conrol LED DISP DP (PB5), so we need to enable it as an output
	PORTB.OUTSET = PIN5_bm; // LED off initially
	PORTB.DIRSET = PIN5_bm; // Enable PB5 as output

	// We also need to change the PORTMUX settings so TCA0WO2 is on PB5 (default is PB2)
	PORTMUX.TCAROUTEA = PORTMUX_TCA02_ALT1_gc;

	// CLK_PER select, /2 prescaler (1.67MHz)
	TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV2_gc;
	// Single-slope PWM mode, WO2 enable (PB5, LED DISP DP)
	TCA0.SINGLE.CTRLB = TCA_SINGLE_WGMODE_SINGLESLOPE_gc | TCA_SINGLE_CMP2EN_bm;
	// Enable overflow interrupt (interrupt at TOP)
	TCA0.SINGLE.INTCTRL = TCA_SINGLE_OVF_bm;
	// Set PWM frequency to 50Hz
	TCA0.SINGLE.PER = 33333; // 50Hz is 33333 clocks @ 1.67 MHz
	// Set duty cycle to 100% initially (LED is active low, so this is OFF)
	TCA0.SINGLE.CMP2 = 33334; // Greater than PER => 100% duty cycle
	// Enable TCA0 (note |= so we dont clobber clock selection)
	TCA0.SINGLE.CTRLA |= TCA_SINGLE_ENABLE_bm;
}
int main(void){
	cli(); // Disable interrupts
	pwm_init(); // Initialise timer TCA0

	_delay_ms(1000); // wait 1 second
	TCA0.SINGLE.CMP2BUF = 25000; // 75% duty
	_delay_ms(1000); // wait 1 second
	TCA0.SINGLE.CMP2BUF = 16667; // 50% duty
	_delay_ms(1000); // wait 1 second
	TCA0.SINGLE.CMP2BUF = 8333; // 25% duty
	_delay_ms(1000); // wait 1 second
	TCA0.SINGLE.CMP2BUF = 0; // 0% duty
	_delay_ms(1000); // wait 1 second

	sei(); // Enable interrupts

	// This program is interrupt driven
	// main() will just idle here
	while(1);
}
ISR(TCA0_OVF_vect){
	// This variable is declared static 
	// its value will persist between invocations of the ISR
	static uint16_t compare;

	// Implement an asymmetric soft flash (~1Hz)
	compare += 1310;

	TCA0.SINGLE.CMP2BUF = compare; // update duty cycle
	TCA0.SINGLE.INTFLAGS = TCA_SINGLE_0VF_bm; // acknowledge interrupt
}
```
### Some Complications
Both `TCA0WO0` and `TCA0WO1` share the same timer/counter (TCA0), so if you are trying to use both simultaneously:
- The outputs must be definition have the same frequency, as the period of the shared counter sets the freqency
- The outpts can have independent duty cycles as they have independent compare registers
- You can also enable and disable these outputs (and whether they are controlled by the `TCA0` peripheral) independently

