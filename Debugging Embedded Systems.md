#cs 
We have a very limited view into the internal operation of a [[Microprocessors & Microcontrollers|Microcontroller]]. More sophisticated (often expensive) debugging tools are available for microcontrollers that let you interrogate the contents of memory as your programme is running.

It is important to develop strategies to be able to systematically debug [[Embedded Systems]] when we only have access to basic I/O.

## Toggling Pins
Toggling a pin is a simple and effective way of getting a simple status indication from a programme running on a microcontroller. If connected to an LED provides an easy visual indicator. Could use more sophistaticated instrumentation (e.g. an oscilloscope) to get more detailed timing information.

Use cases:
- Test whether a section of code is executing (e.g. interrupt)
- Test the timing a section of code (e.g. set a pin at start, clear at end)
- Detect the occurence of infrequent events (set pin on event, never clear)

## Serial Communications
If we need more detailed information that a single pin can provide, use of [[Serial Communication]] is a useful next step.

For simple cases, writing bytes directly to a [[UART]] might be good enough. If we want formatted strings, writing the infrastructure required to use printf/scanf might be worthwhile

Use cases:
- Printing variable values to a serial console to check arithmetic, logic, etc
- Getting user input for interactive debugging, entering test data, etc
- Printing descriptive error messages in the case of an unexpected behaviour

## Using stdio on AVR Microcontrollers
For AVR microcontrollers there is a simple mechanism to rout stdin and stdout to/from any serial communications interface which can read and write characters (e.g. UART, SPI, etc). stdio.h must be included

Step 1: Declare function prototypes for the read/write functions
```c
static int stdio_putchar(char c, FILE *stream);
static int stdio_getchar(FILE *stream);
```
Step 2: Declare a stream to be used for stdin/stdout; the `FDEV_SETUP_STREAM` macro takes as arguments a reference to the functions declared.
```c
static FILE stdio = FDEV_SETUP_STREAM(stdio_putchar, stdio_getchar, _FDEV_SETUP_RW);
```
Step 3: Implement the functions that read/write from the serial interface. The implementation will depend on the particular serial interface used. In this example we use some predefined functions for writing to/reading from the UART.
```c
static int stdio_putchar(char c, FILE *stream){
	uart_putc(c);
	return c;
}
static int stdio_getchar(FILE *stream){
	return uart_getc();
}
```
Step 4: To link the stream we have created to stdin and stdout the following assignments must be made during the intialisation fo your programme:
```c
void stdio_init(void){
	// Assumes serial interface is intitilised elsewhere
	stdout = &stdio;
	stdin = &stdio;
}
```
Usage: Once steps 1-4 have been completed the functions defined in stdio.h (e.g. prinf, scanf) can be used throughout your programme, and characters will be read/writing from the serial interface.

## Assembly Listing 
Some problems are impossible to identify and debug based on the C code alone. In these cases it may be necessary to inspect the assembly code which is generated by the compiler and linker from a C programme.

For the gcc toolchain we can do this using the objdump utility, e.g.:
```c
avr-objdump -d firmware.elf
```
By inspecting the assemmbly directly we can identify problems that might be introduced due to optimisation, low level timing issues, pre-emption of critical code sections by ISRs etc.